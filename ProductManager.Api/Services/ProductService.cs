using System.Text.Json;using Ardalis.Result;using AutoMapper;using FluentValidation;using Microsoft.Extensions.Caching.Memory;using Microsoft.Extensions.Logging;using ProductManager.Api.Helpers;using ProductManager.Api.Interfaces;using ProductManager.Api.Models.DTOs;using ProductManager.Api.Models.Entity;namespace ProductManager.Api.Services;public class ProductService : IProductService{    private readonly string _filePath;    private static readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);    private readonly IMapper _mapper;    private readonly ILogger<ProductService> _logger;    private readonly IValidator<ProductInputDTO> _validator;    private readonly IMemoryCache _cache;    private const string ProductsCacheKey = "Products_All";    public ProductService(        IWebHostEnvironment environment,         IMapper mapper,         ILogger<ProductService> logger,         IValidator<ProductInputDTO> validator,        IMemoryCache cache)    {        _mapper = mapper;        _logger = logger;        _validator = validator;        _cache = cache;        _filePath = Path.Combine(environment.ContentRootPath, "Data", "products.json");        ProductStorageHelper.InitializeStorage(_filePath);    }    public async Task<Result<IEnumerable<ProductDTO>>> GetAllProducts()    {        try        {            _logger.LogInformation("Retrieving all products");                        var products = await GetAllProductEntities();            var productDtos = _mapper.Map<IEnumerable<ProductDTO>>(products);            return Result<IEnumerable<ProductDTO>>.Success(productDtos);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error getting all products");            return Result<IEnumerable<ProductDTO>>.Error("Failed to retrieve products: " + ex.Message);        }    }    public async Task<Result<ProductDTO>> GetProductById(int id)    {        try        {            _logger.LogInformation("Retrieving product with ID {ProductId}", id);                        var products = await GetAllProductEntities();            var product = products.FirstOrDefault(p => p.Id == id);                        if (product == null)            {                _logger.LogWarning("Product with ID {ProductId} not found", id);                return Result<ProductDTO>.NotFound($"Product with ID {id} not found");            }                        var productDto = _mapper.Map<ProductDTO>(product);            _logger.LogInformation("Retrieved product: {ProductName}", productDto.Name);                        return Result<ProductDTO>.Success(productDto);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error getting product with ID {ProductId}", id);            return Result<ProductDTO>.Error($"Failed to retrieve product: {ex.Message}");        }    }    public async Task<Result<ProductDTO>> AddProduct(ProductInputDTO inputDto)    {        _logger.LogInformation("Adding new product {ProductName} in category {Category}",             inputDto.Name, inputDto.Category);                    // Validate using the helper        var validationResult = await ValidationHelper.ValidateProductInput(_validator, inputDto, _logger);        if (!validationResult.IsSuccess)        {            return Result<ProductDTO>.Invalid(validationResult.ValidationErrors);        }                try        {            var products = await GetAllProductEntities();                        var product = _mapper.Map<Product>(inputDto);                        product.Id = ProductStorageHelper.GenerateNewId(products);                        products.Add(product);                        await SaveProducts(products);                        _logger.LogInformation("Product created with ID {ProductId} and name {ProductName}",                 product.Id, product.Name);                            return Result<ProductDTO>.Success(_mapper.Map<ProductDTO>(product));        }        catch (Exception ex)        {            _logger.LogError(ex, "Error adding product");            return Result<ProductDTO>.Error($"Failed to add product: {ex.Message}");        }    }    public async Task<Result> UpdateProduct(int id, ProductInputDTO inputDto)    {        _logger.LogInformation("Updating product with ID {ProductId}", id);                var validationResult = await ValidationHelper.ValidateProductInput(_validator, inputDto, _logger);        if (!validationResult.IsSuccess)        {            return Result.Invalid(validationResult.ValidationErrors);        }                try        {            var products = await GetAllProductEntities();            var index = products.FindIndex(p => p.Id == id);                        if (index == -1)            {                _logger.LogWarning("Product with ID {ProductId} not found for update", id);                return Result.NotFound($"Product with ID {id} not found");            }                        _mapper.Map(inputDto, products[index]);                        await SaveProducts(products);                        _logger.LogInformation("Product updated successfully: ID {ProductId}, Name {ProductName}",                 id, inputDto.Name);                            return Result.Success();        }        catch (Exception ex)        {            _logger.LogError(ex, "Error updating product with ID {ProductId}", id);            return Result.Error($"Failed to update product: {ex.Message}");        }    }    public async Task<Result> DeleteProduct(int id)    {        _logger.LogInformation("Deleting product with ID {ProductId}", id);                try        {            var products = await GetAllProductEntities();            var product = products.FirstOrDefault(p => p.Id == id);                        if (product == null)            {                _logger.LogWarning("Product with ID {ProductId} not found for deletion", id);                return Result.NotFound($"Product with ID {id} not found");            }                        products.Remove(product);                        await SaveProducts(products);                        _logger.LogInformation("Product with ID {ProductId} deleted successfully", id);                        return Result.Success();        }        catch (Exception ex)        {            _logger.LogError(ex, "Error deleting product with ID {ProductId}", id);            return Result.Error($"Failed to delete product: {ex.Message}");        }    }        private async Task<List<Product>> GetAllProductEntities()    {                if (_cache.TryGetValue(ProductsCacheKey, out List<Product> cachedProducts))        {            _logger.LogDebug("Retrieved products from cache");            return new List<Product>(cachedProducts);        }                await _semaphore.WaitAsync();        try        {            using var fileStream = new FileStream(_filePath, FileMode.Open, FileAccess.Read);            using var streamReader = new StreamReader(fileStream);            var json = await streamReader.ReadToEndAsync();                        if (string.IsNullOrEmpty(json))            {                return new List<Product>();            }                        var products = JsonSerializer.Deserialize<List<Product>>(json, ProductStorageHelper.JsonOptions) ?? new List<Product>();                        _cache.Set(ProductsCacheKey, products, CacheHelper.GetDefaultCacheOptions());            _logger.LogDebug("Loaded {Count} products from file and cached them", products.Count);                        return new List<Product>(products);        }        finally        {            _semaphore.Release();        }    }    private async Task SaveProducts(List<Product> products)    {        await _semaphore.WaitAsync();        try        {            using var fileStream = new FileStream(_filePath, FileMode.Create, FileAccess.Write);            using var streamWriter = new StreamWriter(fileStream);            var json = JsonSerializer.Serialize(products, ProductStorageHelper.JsonOptions);            await streamWriter.WriteAsync(json);                        _cache.Set(ProductsCacheKey, products, CacheHelper.GetDefaultCacheOptions());            _logger.LogDebug("Saved {Count} products to file and updated cache", products.Count);        }        finally        {            _semaphore.Release();        }    }}